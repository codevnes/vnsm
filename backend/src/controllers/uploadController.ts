import { Request, Response } from 'express';
import sharp from 'sharp';
import fs from 'fs';
import path from 'path';
import prisma from '../lib/prisma'; // Adjust path if necessary

export const uploadImage = async (req: Request, res: Response): Promise<void> => {
    if (!req.file) {
        res.status(400).json({ message: 'No image file uploaded.' });
        return;
    }

    const { altText } = req.body; // Get alt text from request body
    const originalFile = req.file;
    const tempFilePath = originalFile.path; // Path where multer saved the original
    const processedFilename = originalFile.filename; // Filename generated by multer (already .webp)
    const processedFilePath = path.join(path.dirname(tempFilePath), processedFilename);

    try {
        // --- Image Processing with Sharp ---
        // Note: Since multer saves directly as .webp, we might just adjust quality or resize here
        // If multer saved with original extension, the sharp pipeline would be more crucial
        const processedImageBuffer = await sharp(tempFilePath)
            .resize({ width: 1024, height: 1024, fit: 'inside', withoutEnlargement: true }) // Resize
            .webp({ quality: 80 }) // Ensure WebP with quality 80
            .toBuffer(); // Get buffer to potentially overwrite or verify

        // Overwrite the file saved by multer with the processed version
        fs.writeFileSync(processedFilePath, processedImageBuffer);

        // --- Get Metadata & Construct URL ---
        const stats = fs.statSync(processedFilePath);
        const metadata = await sharp(processedFilePath).metadata();
        const relativePath = `/uploads/images/${processedFilename}`;
        // Construct the full URL (adjust BASE_URL if needed, e.g., from env vars)
        const baseUrl = process.env.BACKEND_URL || `${req.protocol}://${req.get('host')}`;
        const fullUrl = `${baseUrl}${relativePath}`;

        // --- Save Metadata to Database ---
        const imageRecord = await prisma.image.create({
            data: {
                filename: originalFile.originalname,
                processedFilename: processedFilename,
                path: relativePath,
                url: fullUrl,
                altText: altText || null, // Use provided alt text or null
                mimetype: 'image/webp', // We converted to webp
                size: stats.size,
                width: metadata.width,
                height: metadata.height,
            }
        });

        // --- Return Response ---
        res.status(201).json({
            message: 'Image uploaded and processed successfully!',
            data: {
                id: imageRecord.id,
                url: imageRecord.url,
                altText: imageRecord.altText,
                filename: imageRecord.processedFilename
            }
        });

    } catch (error) {
        console.error('Error processing image:', error);
        // Clean up uploaded file if processing fails
        if (fs.existsSync(processedFilePath)) {
            fs.unlinkSync(processedFilePath);
        }
        // If multer saved a different temp file initially, clean that too
        // if (tempFilePath !== processedFilePath && fs.existsSync(tempFilePath)) {
        //     fs.unlinkSync(tempFilePath);
        // }
        res.status(500).json({ message: 'Error processing image.', error: (error as Error).message });
    }
};

// --- NEW: Get All Images --- 
export const getAllImages = async (req: Request, res: Response): Promise<void> => {
    const { limit = '10', offset = '0' } = req.query; // Default pagination

    const limitNum = parseInt(limit as string, 10);
    const offsetNum = parseInt(offset as string, 10);

    if (isNaN(limitNum) || isNaN(offsetNum) || limitNum <= 0 || offsetNum < 0) {
        res.status(400).json({ message: 'Invalid pagination parameters.' });
        return;
    }

    try {
        const images = await prisma.image.findMany({
            take: limitNum,
            skip: offsetNum,
            orderBy: {
                createdAt: 'desc' // Order by newest first
            }
        });

        const totalImages = await prisma.image.count(); // Get total count for pagination info

        res.status(200).json({
            message: 'Images retrieved successfully',
            data: images,
            pagination: {
                total: totalImages,
                limit: limitNum,
                offset: offsetNum,
                hasNextPage: offsetNum + limitNum < totalImages
            }
        });
    } catch (error) {
        console.error('Error retrieving images:', error);
        res.status(500).json({ message: 'Error retrieving images.', error: (error as Error).message });
    }
};

// --- NEW: Get Image By ID --- 
export const getImageById = async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    const imageId = parseInt(id, 10);

    if (isNaN(imageId)) {
        res.status(400).json({ message: 'Invalid image ID format.' });
        return;
    }

    try {
        const image = await prisma.image.findUnique({
            where: { id: imageId }
        });

        if (!image) {
            res.status(404).json({ message: 'Image not found.' });
            return;
        }

        res.status(200).json({
            message: 'Image retrieved successfully',
            data: image
        });
    } catch (error) {
        console.error(`Error retrieving image with ID ${imageId}:`, error);
        res.status(500).json({ message: 'Error retrieving image.', error: (error as Error).message });
    }
};

// --- NEW: Update Image Metadata (e.g., alt text) --- 
export const updateImage = async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    const { altText } = req.body; // Get updated altText from body
    const imageId = parseInt(id, 10);

    if (isNaN(imageId)) {
        res.status(400).json({ message: 'Invalid image ID format.' });
        return;
    }

    // Basic validation: Ensure altText is provided if something is being updated
    // Extend this if more fields become updatable
    if (altText === undefined) {
        res.status(400).json({ message: 'No update data provided (e.g., altText).' });
        return;
    }

    try {
        // Check if image exists first (optional, update directly if preferred)
        const existingImage = await prisma.image.findUnique({
            where: { id: imageId },
        });

        if (!existingImage) {
            res.status(404).json({ message: 'Image not found.' });
            return;
        }

        // Update the image record
        const updatedImage = await prisma.image.update({
            where: { id: imageId },
            data: {
                altText: altText, // Update altText
                // Add other fields here if they become updatable
            },
        });

        res.status(200).json({
            message: 'Image metadata updated successfully',
            data: updatedImage,
        });
    } catch (error) {
        console.error(`Error updating image with ID ${imageId}:`, error);
        res.status(500).json({ message: 'Error updating image metadata.', error: (error as Error).message });
    }
};

// --- NEW: Delete Image (Record and File) ---
export const deleteImage = async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    const imageId = parseInt(id, 10);

    if (isNaN(imageId)) {
        res.status(400).json({ message: 'Invalid image ID format.' });
        return;
    }

    try {
        // Find the image record to get the file path before deleting
        const imageToDelete = await prisma.image.findUnique({
            where: { id: imageId },
        });

        if (!imageToDelete) {
            res.status(404).json({ message: 'Image not found.' });
            return;
        }

        // Delete the image record from the database
        await prisma.image.delete({
            where: { id: imageId },
        });

        // Construct the absolute path to the image file
        const filePath = path.join(__dirname, '../../public', imageToDelete.path);

        // Delete the file from the server
        if (fs.existsSync(filePath)) {
            fs.unlink(filePath, (err) => {
                if (err) {
                    // Log error but proceed, DB record is already deleted
                    console.error(`Error deleting image file ${filePath}:`, err);
                }
            });
        } else {
             console.warn(`Image file not found for deletion: ${filePath}`);
        }

        res.status(204).send(); // Send 204 No Content on successful deletion

    } catch (error) {
        console.error(`Error deleting image with ID ${imageId}:`, error);
        // Note: If DB delete fails, file won't be deleted.
        // If DB delete succeeds but file delete fails, the record is gone but file remains (orphaned).
        res.status(500).json({ message: 'Error deleting image.', error: (error as Error).message });
    }
}; 